<body>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lambda Calculus | Tim’s code stuff</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="Lambda Calculus">
<meta property="og:locale" content="en_US">
<meta name="description" content="Learning Outcomes">
<meta property="og:description" content="Learning Outcomes">
<meta property="og:site_name" content="Tim’s code stuff">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-08-01T23:48:52+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Lambda Calculus">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-01T23:48:52+00:00","datePublished":"2024-08-01T23:48:52+00:00","description":"Learning Outcomes","headline":"Lambda Calculus","mainEntityOfPage":{"@type":"WebPage","@id":"/lambdacalculus/"},"url":"/lambdacalculus/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/assets/images/favicon.ico">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/css/styles.css">
<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Tim’s code stuff">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-159840333-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-159840333-1');
</script><script src="/assets/js/spoilers.js" defer></script>

  <header class="site-header">

    <div class="wrapper">
<a class="site-title" rel="author" href="/">Tim’s code stuff</a>
        <script src="/assets/js/hide_solutions.js" defer></script><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger">
            <label for="nav-trigger">
            <span class="menu-icon">
                <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
                </svg>
            </span>
            </label>

            <div class="trigger">
<a class="page-link" href="/about/">About</a><a class="page-link" href="/">Notes on Programming Paradigms</a><!-- Radio Switch -->
            <div id="toggle-div" style="display: none;">
                <p class="page-link" style="margin-bottom: 0px;">Show Solutions?</p>
                <label class="switch" style="vertical-align: middle;">
                    <input type="checkbox" id="toggle-switch">
                    <span class="slider round"></span>
                </label>
            </div>
            </div>
        </nav>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/higherorderfunctions/">&lt; <span class="glossary-term" data-term="higher-order functions">Higher-Order Functions<span class="glossary-popup">A function that takes other functions as arguments or returns a function as its result.
</span></span></a>
      
      
        
        
        <a id="right" href="/purescript/">From JavaScript to Haskell (via PureScript) &gt;</a>
      
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</div>

	<header class="post-header">
		<h1 class="post-title">Lambda Calculus</h1>
	</header>
	<p id="readingTime">

  
  19

 min read</p>
	<div class="post-content">
		<h2 id="learning-outcomes">Learning Outcomes</h2>

<ul>
  <li>Understand that the <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> provides a complete model of computation</li>
  <li>Relate the <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> to <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming</li>
  <li>Apply conversion and reduction rules to simplify <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>
</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>The <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> is a model of computation developed in the 1930s by the mathematician Alonzo Church.  You are probably aware of the more famous model for computation developed around the same time by Alan Turing: the <span class="glossary-term" data-term="turing machine">Turing Machine<span class="glossary-popup">A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.
</span></span>.  However, while the <span class="glossary-term" data-term="turing machine">Turing Machine<span class="glossary-popup">A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.
</span></span> is based on a hypothetical physical machine (involving tapes from which instructions are read and written) the <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> was conceived as a set of rules and operations for function abstraction and application.  It has been proven that, as a model of computation, the <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> is just as powerful as <span class="glossary-term" data-term="turing machines">Turing Machines<span class="glossary-popup">A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.
</span></span>, that is, any computation that can be modelled with a <span class="glossary-term" data-term="turing machine">Turing Machine<span class="glossary-popup">A model of computation based on a hypothetical machine reading or writing instructions on a tape, which decides how to proceed based on the symbols it reads from the tape.
</span></span> can also be modeled with the <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span>.</p>

<p>The <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> is also important to study as it is the basis of <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming.  The operations we can apply to <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> expressions to simplify (or reduce) them, or to prove equivalence, can also be applied to <span class="glossary-term" data-term="pure functions">pure functions<span class="glossary-popup">A function that always produces the same output for the same input and has no side effects.
</span></span> in a programming language that supports <a href="/higherorderfunctions"><span class="glossary-term" data-term="higher-order functions">higher-order functions<span class="glossary-popup">A function that takes other functions as arguments or returns a function as its result.
</span></span></a>.</p>

<h2 id="lambda-expressions">Lambda Expressions</h2>

<p><span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> expressions are written with a standard system of notation.  It is worth looking at this notation before studying haskell-like languages because it was the inspiration for Haskell <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span>.  Here is a simple Lambda Abstraction of a function:</p>

<pre><code class="language-lambdacalc">λx.x
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">λ</code> (Greek letter Lambda) simply denotes the start of a function expression. Then follows a list of parameters (in this case we have only a single parameter called <code class="language-plaintext highlighter-rouge">x</code>) terminated by <code class="language-plaintext highlighter-rouge">.</code>.  After the <code class="language-plaintext highlighter-rouge">.</code> is the function body, an expression returned by the function when it is applied. A variable like <code class="language-plaintext highlighter-rouge">x</code> that appears in the function body and also the parameter list is said to be <em>bound</em> to the parameter.  Variables that appear in the function body but not in the parameter list are said to be <em>free</em>.  The above lambda expression is equivalent to the JavaScript expression:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span>
</code></pre></div></div>

<hr>

<h3 id="exercise">Exercise</h3>

<p>When we discussed <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> in JavaScript, we gave this function a name.  What was it?</p>

<div class="solutions">
    
<h3 id="solutions">Solutions</h3>

<p>It was the <a href="/higherorderfunctions#identity-i-combinator">I-<span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span></a>*</p>


</div>

<hr>

<p>Some things to note about such <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>:</p>

<ul>
  <li>A lambda expression has no name, it is anonymous.  Note that <span class="glossary-term" data-term="anonymous functions">anonymous functions<span class="glossary-popup">A function defined without a name, often used as an argument to other functions. Also known as lambda function.
</span></span> in languages like JavaScript and Python are also frequently called <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>, or just lambdas.  Now you know why.</li>
  <li>The only values that <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> variables can take on is other functions (i.e. <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>).  It’s lambdas all the way down!  However, to actually model and perform useful computations we say that certain expressions represent values.  See the discussion of <a href="#church-encodings">Church Encodings</a>, below, to see how this is done.</li>
  <li>The names of variables bound to parameters in a lambda expression are only meaningful within the context of that expression.  Thus, <code class="language-plaintext highlighter-rouge">λx.x</code> is semantically equivalent (or <em>alpha</em> equivalent) to <code class="language-plaintext highlighter-rouge">λy.y</code> or any other possible renaming of the variable.</li>
  <li>Lambda functions can have multiple parameters in the parameter list, e.g.: <code class="language-plaintext highlighter-rouge">λxy. x y</code>, but they are implicitly curried (e.g. a sequence of nested univariate functions).  Thus the following are all equivalent:</li>
</ul>

<pre><code class="language-lambdacalc">λxy.xy
= λx.λy.xy
= λx.(λy.xy)
</code></pre>

<h2 id="combinators">Combinators</h2>

<p>We have already discussed <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> in JavaScript, now we can give them a more formal definition:</p>

<ul>
  <li>A <strong><span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span></strong> is a lambda expression (function) with no free variables.</li>
</ul>

<p>Thus, the expression <code class="language-plaintext highlighter-rouge">λx.x</code> is a <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> because the variable <code class="language-plaintext highlighter-rouge">x</code> is bound to the parameter.  The expression <code class="language-plaintext highlighter-rouge">λx.xy</code> is not a <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span>, because <code class="language-plaintext highlighter-rouge">y</code> is not bound to any parameter, it is <em>free</em>.</p>

<p>The <a href="/higherorderfunctions/#k-combinator"><code class="language-plaintext highlighter-rouge">K</code> <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span></a> which we wrote as <code class="language-plaintext highlighter-rouge">x=&gt;y=&gt;x</code> in JavaScript, is written <code class="language-plaintext highlighter-rouge">λxy.x</code>.</p>

<h2 id="application">Application</h2>

<p>What can we do with such a lambda expression?  Well we can <em>apply</em> it to another expression (The same way we can <em>apply</em> <span class="glossary-term" data-term="anonymous functions">anonymous functions<span class="glossary-popup">A function defined without a name, often used as an argument to other functions. Also known as lambda function.
</span></span> to an argument in JavaScript).  Here, we apply the lambda <code class="language-plaintext highlighter-rouge">(λx.x)</code> to the variable <code class="language-plaintext highlighter-rouge">y</code>:</p>

<pre><code class="language-lambdacalculus">(λx.x)y
</code></pre>

<p>Note that while in JavaScript application of a function <code class="language-plaintext highlighter-rouge">(x=&gt;x)</code> to an argument <code class="language-plaintext highlighter-rouge">y</code> requires brackets around the argument: <code class="language-plaintext highlighter-rouge">(x=&gt;x)(y)</code>, in the <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> application of some expression <code class="language-plaintext highlighter-rouge">f</code> to some other expression <code class="language-plaintext highlighter-rouge">x</code> is indicated simply <code class="language-plaintext highlighter-rouge">fx</code>.  Brackets are required to delineate the start and end of an expression, e.g. in <code class="language-plaintext highlighter-rouge">(λx.x)y</code>, the brackets make it clear that <code class="language-plaintext highlighter-rouge">y</code> is not part of the lambda <code class="language-plaintext highlighter-rouge">λx.x</code>, but rather the lambda is being applied to <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p>We can reduce this expression to a simpler form by a substitution, indicated by a bit of intermediate notation.  Two types of annotations are commonly seen, you can use either (or both!):</p>

<pre><code class="language-lambdacalculus">x [x:=y]         -- an annotation on the right of the lambda body showing the substitution that will be applied to the expression on the left
(λx [x:=y].x)    -- an annotation inside the parameter list showing the substitution that will be performed inside the body (arguments have already been removed)
</code></pre>

<p>Now we perform the substitution in the body of the expression and throw away the head, since all the bound variables are substituted, leaving only:</p>

<pre><code class="language-lambdacalc">y
</code></pre>

<p>This first reduction rule, substituting the arguments of a function application to all occurrences of that parameter inside the function body, is called <em><span class="glossary-term" data-term="beta reduction">beta reduction<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span></em>.</p>

<p>The next rule arises from the observation that, for some lambda term <code class="language-plaintext highlighter-rouge">M</code> that does not involve <code class="language-plaintext highlighter-rouge">x</code>:</p>

<pre><code class="language-lambdacalc">λx.Mx
</code></pre>

<p>is just the same as M.  This last rule is called <em>eta conversion</em>.</p>

<p>Function application is left-associative except where terms are grouped together by brackets.  This means that when a Lambda expression involves more than two terms, <span class="glossary-term" data-term="beta reduction">BETA reduction<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span> is applied left to right, i.e.,</p>

<p><code class="language-plaintext highlighter-rouge">(λz.z) (λa.a a)  (λz.z b) = ( (λz.z) (λa.a a) ) (λz.z b)</code>.</p>

<div class="cheatsheet">

  <h2 id="lambda-calculus-cheatsheet">Lambda Calculus Cheatsheet</h2>

  <p>Three operations can be applied to <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>:</p>

  <p><strong><span class="glossary-term" data-term="alpha equivalence">Alpha Equivalence<span class="glossary-popup">Renaming variables in lambda expressions as long as the names remain consistent within the scope.
</span></span></strong>: variables can be arbitrarily renamed as long as the names remain consistent within the scope of the expression.</p>

  <pre><code class="language-lambda">λxy.yx = λwv.vw
</code></pre>

  <p><strong><span class="glossary-term" data-term="beta reduction">Beta Reduction<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span></strong>: functions are applied to their arguments by substituting the text of the argument in the body of the function.</p>

  <pre><code class="language-lambda">(λx. x) y
= (λx [x:=y]. x)     - we indicate the substitution that is going to occur inside []
= x [x:=y]           - an alternative way to show the substitution
= y
</code></pre>

  <p><strong>Eta Conversion</strong>: functions that simply apply another expression to their argument can be substituted with the expression in their body.</p>

  <pre><code class="language-lambda">λx.Mx
= M
</code></pre>

</div>

<p>One thing to note about the <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> is that it does not have any such thing as a global namespace.  All variables must be:</p>

<ul>
  <li>Parameters from some enclosing lambda expression (note, below we start using labels to represent expressions - these are not variables, just placeholders for an expression that can be substituted for the label).</li>
  <li>Immutable - there is no way to assign a new value to a variable from within a lambda expression.</li>
</ul>

<p>This makes the language and its evaluation very simple.  All we (or any hypothetical machine for evaluating <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>) can do with a lambda is apply the three basic alpha, beta and eta reduction and conversion rules.  Here’s a fully worked example of applying the different rules to reduce an expression until no more <span class="glossary-term" data-term="beta reduction">Beta reduction<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span> is possible, at which time we say it is in <em>beta normal form</em>:</p>

<pre><code class="language-lambdacalc">(λz.z) (λa.a a) (λz.z b)
⇒
((λz.z) (λa.a a)) (λz.z b)    =&gt; Function application is left-associative
⇒
(z [z:=λa.a a]) (λz.z b)      =&gt; BETA Reduction
⇒
(λa.a a) (λz.z b)
⇒
a a [a:=λz.z b]               =&gt; BETA Reduction
⇒
(λz.z b) (λz.z b)
⇒
z b [z:=(λz.z b)]             =&gt; BETA Reduction
⇒
(λz.z b) b
⇒
z b [z:=b]                    =&gt; BETA Reduction
⇒
b b         =&gt; Beta normal form, cannot be reduced again.
</code></pre>

<p>Note, sometimes I add extra spaces as above just to make things a little more readable - but it doesn’t change the order of application, indicate a variable is not part of a lambda to its left (unless there is a bracket) or have any other special meaning.</p>

<h2 id="church-encodings">Church Encodings</h2>

<p>And yet, this simple calculus is sufficient to perform computation.  Alonzo Church demonstrated that we can model any of the familiar programming language constructs with <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>.  For example, Booleans:</p>

<pre><code class="language-lambda">TRUE = λxy.x    = K-combinator
FALSE = λxy.y   = K I
</code></pre>

<p>Note that we are making use of the K and I <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> here as we did for the head and rest functions for our <a href="/higherorderfunctions/#k-combinator">cons list</a>, i.e. returning either the first or second parameter to make a choice between two options.  Now we can make an IF expression:</p>

<pre><code class="language-lambda">IF = λbtf.b t f
</code></pre>

<p><code class="language-plaintext highlighter-rouge">IF TRUE</code> returns the expression passed in as <code class="language-plaintext highlighter-rouge">t</code> and <code class="language-plaintext highlighter-rouge">IF FALSE</code> returns the expression passed in as <code class="language-plaintext highlighter-rouge">f</code>.  Now we can make Boolean operators:</p>

<pre><code class="language-lambda">AND = λxy. IF x  y FALSE
OR = λxy. IF x TRUE y 
NOT = λx. IF x FALSE TRUE
</code></pre>

<p>And now we can evaluate logical expressions with <span class="glossary-term" data-term="beta reduction">beta reduction<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span>:</p>

<pre><code class="language-lambda">NOT TRUE
= (λx. IF x FALSE TRUE) TRUE       - expand NOT
= IF x FALSE TRUE [x:=TRUE]        - beta reduction
= IF TRUE FALSE TRUE
= (λbtf.b t f) TRUE FALSE TRUE     - expand IF
= b t f [b:=TRUE,t:=FALSE,f:=TRUE] - beta reduction
= TRUE FALSE TRUE
= (λxy.x) FALSE TRUE               - expand TRUE
= x [x:=FALSE]                     - beta reduction
= FALSE
</code></pre>

<p>Alonzo Church also demonstrated an encoding for natural numbers:</p>

<pre><code class="language-lambda">0 = λfx.x = K I
1 = λfx.f x
2 = λfx.f (f x)
</code></pre>

<p>In general a natural number <code class="language-plaintext highlighter-rouge">n</code> has two arguments <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">x</code>, and iterates <code class="language-plaintext highlighter-rouge">f</code> <code class="language-plaintext highlighter-rouge">n</code> times. The successor of a natural number <code class="language-plaintext highlighter-rouge">n</code> can also be computed:</p>

<pre><code class="language-lambda">SUCC = λnfx.f (n f x)

SUCC 2
= (λnfx.f (n f x)) 2
= (λfx.f (n f x)) [n:=2]
= (λfx.f (2 f x))
= (λfx.f ((λfx.f (f x)) f x))
= (λfx.f ((f (f x)) [f:=f,x:=x]))
= (λfx.f (f (f x)))
= 3
</code></pre>

<hr>

<h3 id="exercises">Exercises</h3>

<ul>
  <li>Try using <span class="glossary-term" data-term="beta reduction">beta reduction<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span> to compute some more logical expressions.  E.g. make an expression for XOR.</li>
  <li>Our JavaScript <a href="/higherorderfunctions/#k-combinator">cons list</a> was based on the Church Encoding for linked lists.  Try writing the <code class="language-plaintext highlighter-rouge">cons</code>, <code class="language-plaintext highlighter-rouge">head</code> and <code class="language-plaintext highlighter-rouge">rest</code> functions as <span class="glossary-term" data-term="lambda expressions">Lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span>.</li>
  <li>Investigate <a href="https://en.wikipedia.org/wiki/Church_encoding">Church Numerals</a> and try using <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> to compute some basic math.</li>
</ul>

<div class="solutions">
    
<h4 id="solutions">Solutions</h4>

<ul>
  <li>First, let’s recall the definition of XOR: If either, but not both, of the inputs is true, then the output is true.</li>
</ul>

<pre><code class="language-lambda">XOR = λxy. IF x (NOT y) y
</code></pre>

<pre><code class="language-lambda">XOR TRUE FALSE

= (λxy. IF x (NOT y) y) TRUE FALSE - expand XOR
= IF x (NOT y) y [x:=TRUE, y:=FALSE] - beta reduction
= IF (TRUE) (NOT FALSE) TRUE
= (λbtf.b t f) TRUE (NOT FALSE) TRUE - expand IF
= b t f [b:=TRUE,t:=(NOT FALSE),f:=TRUE] - beta reduction
= TRUE (NOT FALSE) TRUE
= (λxy.x) (NOT FALSE) TRUE - expand TRUE
= x [x:=(NOT FALSE), y:=TRUE] - beta reduction
= NOT FALSE
= (λx. IF x FALSE TRUE) FALSE - expand NOT
= IF x FALSE TRUE (x:=FALSE)
= IF FALSE FALSE TRUE
= (λbtf.b t f) FALSE FALSE TRUE - expand IF
= b t f [b:=FALSE,t:=FALSE,f:=TRUE] - beta reduction
= FALSE FALSE TRUE
= (λxy.y) FALSE TRUE - expand FALSE
= y [x:=FALSE, y:=TRUE] - beta reduction
= TRUE
</code></pre>

<pre><code class="language-lambda">XOR TRUE TRUE

= (λxy. IF x (NOT y) y) TRUE TRUE - expand XOR
= IF x (NOT y) y [x:=TRUE, y:=TRUE] - beta reduction
= IF (TRUE) (NOT TRUE) TRUE
= (λbtf.b t f) TRUE (NOT TRUE) TRUE - expand IF
= b t f [b:=TRUE,t:=(NOT TRUE),f:=TRUE] - beta reduction
= TRUE (NOT TRUE) TRUE
= (λxy.x) (NOT TRUE) TRUE - expand TRUE
= x [x:=(NOT TRUE), y:=TRUE] - beta reduction
= NOT TRUE
= (λx. IF x FALSE TRUE) TRUE - expand NOT
= IF x FALSE TRUE (x:=TRUE)
= IF TRUE FALSE TRUE
= (λbtf.b t f) TRUE FALSE TRUE - expand IF
= b t f [b:=TRUE,t:=FALSE,f:=TRUE] - beta reduction
= TRUE FALSE TRUE
= (λxy.x) FALSE TRUE - expand TRUE
= x [x:=FALSE, y:=TRUE] - beta reduction
= FALSE
</code></pre>


</div>

<hr>

<h2 id="divergent-lambda-expressions">Divergent Lambda Expressions</h2>

<p>Despite the above demonstration of evaluation of logical expressions, the restriction that <span class="glossary-term" data-term="lambda expressions">lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span> are anonymous makes it a bit difficult to see how <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> can be a general model for useful computation.  For example, how can we have a loop?  How can we have recursion if a lambda expression does not have any way to refer to itself?</p>

<p>The first hint to how loops might be possible with <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> is the observation that some expressions do not simplify when beta reduced.  For example:</p>

<pre><code class="language-lambda">( λx . x  x) ( λy. y y)   - (1)
x x [x:= y. y y]
( λy . y  y) ( λy. y y)   - which is alpha equivalent to what we started with, so goto (1)
</code></pre>

<p>Thus, the reduction would go on forever.  Such an expression is said to be divergent.  However, if a lambda function is not able to refer to itself it is still not obvious how recursion is possible.</p>

<p>The answer is due to the American mathematician Haskell Curry and is called the fixed-point or Y <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span>:</p>

<pre><code class="language-lambda"> Y = λf. ( λx . f (x x) ) ( λx. f (x x) )
</code></pre>

<p>When we apply <code class="language-plaintext highlighter-rouge">Y</code> to another function <code class="language-plaintext highlighter-rouge">g</code> we see an interesting divergence:</p>

<pre class="code">
Y g = (λf. ( λx . f (x x) ) ( λx. f (x x) ) ) g
    = ( λx . f (x x) ) ( λx. f (x x) ) [f:=g]  <i>- beta reduction</i>
    = <b>( λx . g (x x) ) ( λx. g (x x) )</b>         <i>- a partial expansion of Y g, remember this…</i>
    = g (x x) [ x:= λx. g (x x)]               <i>- beta reduction</i>
    = g ( <b>(λx. g (x x) ) (λx. g (x x) )</b> )      <i>- bold part matches Y g above, so now…</i>
    = g (Y g)
<i>  … more beta reduction as above
  … followed by substitution with Y g when we see the pattern above…</i>
    = g (g (Y g))
    = g (g (g (Y g)))
<i>  … etc</i>
</pre>

<p>If we directly translate the above version of the Y-<span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> into JavaScript we get the following:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Y</span> <span class="o">=</span> <span class="nx">f</span><span class="o">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)))(</span><span class="nx">x</span><span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span> <span class="c1">// warning infinite recursion ahead!</span>
</code></pre></div></div>

<p>So now <code class="language-plaintext highlighter-rouge">Y</code> is just a function which can be applied to another function, but what sort of function do we pass into <code class="language-plaintext highlighter-rouge">Y</code>?  If we are to respect the rules of the <span class="glossary-term" data-term="lambda calculus">Lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> we cannot have a function that calls itself directly.  That is, because <span class="glossary-term" data-term="lambda expressions">Lambda expressions<span class="glossary-popup">Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.
</span></span> have no name, they can’t refer to themselves by name.</p>

<p>Therefore, we need to wrap the recursive function in a lambda expression into which a reference to the recursive function itself can be passed as parameter.  We can then in the body of the function refer to the parameter function by name.
It’s a bit weird, let me just give you a JavaScript function which fits the bill:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A function that recursively calculates “n!”</span>
<span class="c1">//  - but it needs to be reminded of its own name in the f parameter in order to call itself.</span>
<span class="kd">const</span> <span class="nx">FAC</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span><span class="o">&gt;</span><span class="mi">1</span> <span class="p">?</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Now we can make this function compute factorials like so:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">())))))(</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>720</p>
</blockquote>

<p>Because we gave FAC a stopping condition, we can call too many times and it will still terminate:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">(</span><span class="nx">FAC</span><span class="p">()))))))))(</span><span class="mi">6</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>720</p>
</blockquote>

<p>From the expansion of <code class="language-plaintext highlighter-rouge">Y g = g (g (g (…)))</code> it would seem that <code class="language-plaintext highlighter-rouge">Y(FAC)</code> would give us the recurrence we need. But will the JavaScript translation of the Y-<span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> be able to generate this sequence of calls?</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Y</span><span class="p">(</span><span class="nx">FAC</span><span class="p">)(</span><span class="mi">6</span><span class="p">))</span>
</code></pre></div></div>

<blockquote>
  <p>stack overflow</p>
</blockquote>

<p>Well we got a recurrence, but unfortunately the JavaScript engine’s strict (or eager) evaluation means that we must completely evaluate Y(FAC) before we can ever apply the returned function to (6).<br>
Therefore, we get an infinite loop - and actually it doesn’t matter what function we pass in to Y, it will never actually be called and any stopping condition will never be checked.
How do we restore the laziness necessary to make progress in this recursion?</p>

<p>(<strong>Hint:</strong> it involves wrapping some part of <code class="language-plaintext highlighter-rouge">Y</code> in another lambda)</p>

<p>Did you get it?  If so, good for you!  If not, never mind, it is tricky and in fact was the subject of research papers at one time, so I’ll give you a bigger hint.</p>

<p><strong>Bigger hint:</strong> there’s another famous <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> called <code class="language-plaintext highlighter-rouge">Z</code> which is basically <code class="language-plaintext highlighter-rouge">Y</code> adapted to work with strict evaluation:</p>

<pre><code class="language-lc">Z=λf.(λx.f(λv.xxv))(λx.f(λv.xxv))
</code></pre>

<hr>

<h3 id="exercises-1">Exercises</h3>

<ul>
  <li>Note the similarities between <code class="language-plaintext highlighter-rouge">Y</code> and <code class="language-plaintext highlighter-rouge">Z</code> and perform a similar set of <span class="glossary-term" data-term="beta reductions">Beta reductions<span class="glossary-popup">Substituting the arguments of a function application into the function body.
</span></span> on <code class="language-plaintext highlighter-rouge">Z FAC</code> to see how it forces FAC to be evaluated.</li>
  <li>Write a version of the Z-<span class="glossary-term" data-term="combinator">Combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> in JavaScript such that <code class="language-plaintext highlighter-rouge">Z(FAC)(6)</code> successfully evaluates to <code class="language-plaintext highlighter-rouge">720</code>.</li>
</ul>

<p>Key Idea:</p>

<ul>
  <li>The Z-<span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> introduces an additional lambda to delay the evaluation of the recursive call.</li>
  <li>This ensures that each step of the recursion only evaluates when needed, preventing infinite immediate recursion.</li>
</ul>

<!-- Not sure? -->

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Z</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)))(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">(</span><span class="nx">x</span><span class="p">)(</span><span class="nx">v</span><span class="p">)));</span>
<span class="kd">const</span> <span class="nx">FAC</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">?</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Z</span><span class="p">(</span><span class="nx">FAC</span><span class="p">)(</span><span class="mi">6</span><span class="p">));</span> <span class="c1">// Should print 720</span>
</code></pre></div></div>

<hr>

<h2 id="conclusion">Conclusion</h2>

<p>If you want to dig deeper there is much <a href="https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec07-encodings.pdf">more written about <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> encodings</a> of logical expressions, natural numbers, as well as the <code class="language-plaintext highlighter-rouge">Y</code> and <code class="language-plaintext highlighter-rouge">Z</code> <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span>, and also <a href="https://benestudio.co/fixed-point-combinators-in-javascript/">more about their implementation in JavaScript</a>.</p>

<p>However, the above description should be enough to give you a working knowledge of how to apply the three operations to manipulate <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> expressions, as well as an appreciation for how they can be used to reason about <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> in real-world <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> style curried code.  The other important take away is that the <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> is a turing-complete model of computation, with Church encodings demonstrating how beta-reduction can evaluate church-encoded logical and numerical expressions and the trick of the Y-<span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> giving us a way to perform loops.</p>

<div class="glossary">
  <h2 id="glossary">Glossary</h2>

  <p><em>Lambda Calculus</em>: Model of computation developed in the 1930s by Alonzo Church, providing a complete model of computation similar to Turing Machines.</p>

  <p><em>Lambda expressions</em>: Functions written using the λ notation, e.g., λx.x, which are anonymous and can only take on other functions as values.</p>

  <p><em>Alpha equivalence</em>: Renaming variables in lambda expressions as long as the names remain consistent within the scope.</p>

  <p><em>Beta reduction</em>: Substituting the arguments of a function application into the function body.</p>

  <p><em>Eta conversion</em>: Substituting functions that simply apply another expression to their argument with the expression in their body.</p>

  <p><em>Combinator</em>: A lambda expression with no free variables.</p>

  <p><em>Divergent lambda expressions</em>: Expressions that do not simplify when beta reduced, leading to infinite loops.</p>

</div>

	</div>
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/higherorderfunctions/">&lt; <span class="glossary-term" data-term="higher-order functions">Higher-Order Functions<span class="glossary-popup">A function that takes other functions as arguments or returns a function as its result.
</span></span></a>
      
      
        
        
        <a id="right" href="/purescript/">From JavaScript to Haskell (via PureScript) &gt;</a>
      
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</div>

</article>
      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <!-- <p class="feed-subscribe">
            <a href="/feed.xml">
              <svg class="svg-icon orange">
                <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
              </svg><span>Subscribe</span>
            </a>
          </p> -->
        </div>
        <div class="footer-col">
          <p>Examples and tutorials for various programming paradigms.</p>
        </div>
      </div>
  
      <div class="social-links">
<ul class="social-media-list">
<li><a href="https://github.com/tgdwyer"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">tgdwyer</span></a></li>
<li><a href="https://www.twitter.com/immersivecola"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">immersivecola</span></a></li>
</ul>
</div>
  
    </div>
  
  </footer>


</body>