<body>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>From JavaScript to Haskell (via PureScript) | Tim’s code stuff</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="From JavaScript to Haskell (via PureScript)">
<meta property="og:locale" content="en_US">
<meta name="description" content="Learning Outcomes">
<meta property="og:description" content="Learning Outcomes">
<meta property="og:site_name" content="Tim’s code stuff">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-08-01T23:48:52+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="From JavaScript to Haskell (via PureScript)">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-01T23:48:52+00:00","datePublished":"2024-08-01T23:48:52+00:00","description":"Learning Outcomes","headline":"From JavaScript to Haskell (via PureScript)","mainEntityOfPage":{"@type":"WebPage","@id":"/purescript/"},"url":"/purescript/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/assets/images/favicon.ico">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/css/styles.css">
<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Tim’s code stuff">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-159840333-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-159840333-1');
</script><script src="/assets/js/spoilers.js" defer></script>

  <header class="site-header">

    <div class="wrapper">
<a class="site-title" rel="author" href="/">Tim’s code stuff</a>
        <script src="/assets/js/hide_solutions.js" defer></script><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger">
            <label for="nav-trigger">
            <span class="menu-icon">
                <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
                </svg>
            </span>
            </label>

            <div class="trigger">
<a class="page-link" href="/about/">About</a><a class="page-link" href="/">Notes on Programming Paradigms</a><!-- Radio Switch -->
            <div id="toggle-div" style="display: none;">
                <p class="page-link" style="margin-bottom: 0px;">Show Solutions?</p>
                <label class="switch" style="vertical-align: middle;">
                    <input type="checkbox" id="toggle-switch">
                    <span class="slider round"></span>
                </label>
            </div>
            </div>
        </nav>
</div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/lambdacalculus/">&lt; <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span></a>
      
      
        
        
        <a id="right" href="/haskell1/">Creating and Running Haskell Programs &gt;</a>
      
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</div>

	<header class="post-header">
		<h1 class="post-title">From JavaScript to Haskell (via PureScript)</h1>
	</header>
	<p id="readingTime">

  
  15

 min read</p>
	<div class="post-content">
		<h2 id="learning-outcomes">Learning Outcomes</h2>

<ul>
  <li>Compare a lambda-calculus inspired Haskell-like language (PureScript) with the <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming concepts explored earlier in JavaScript</li>
  <li>Understand how <span class="glossary-term" data-term="tail call optimisation">tail call optimisation<span class="glossary-popup">A compiler feature that optimises tail-recursive functions to prevent additional stack frames from being created, effectively converting recursion into iteration.1
</span></span> is applied in languages which support it</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>JavaScript is a multiparadigm language that—due to its support for functions as objects, <span class="glossary-term" data-term="closures">closures<span class="glossary-popup">A function and the set of variables it accesses from its enclosing scope.
</span></span> and, therefore, <span class="glossary-term" data-term="higher-order functions">higher-order functions<span class="glossary-popup">A function that takes other functions as arguments or returns a function as its result.
</span></span>—is able to be used in a <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming style.  However, if you are really enamoured with <span class="glossary-term" data-term="currying">currying<span class="glossary-popup">The process of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.
</span></span> and combining <span class="glossary-term" data-term="higher-order functions">higher-order functions<span class="glossary-popup">A function that takes other functions as arguments or returns a function as its result.
</span></span>, then it really makes a lot of sense to use a language that is actually designed for it.</p>

<p>There are a number of purpose-built <span class="glossary-term" data-term="functional">Functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> Programming languages.  Lisp (as we have already discussed) is the original, but there are many others.  <a href="https://www.scheme.com/tspl4/">Scheme</a> is a Lisp derivative, as is (more recently) <a href="https://clojure.org/">Clojure</a>.  SML and its derivatives (e.g. <a href="https://ocaml.org/">OCaml</a>, <a href="https://fsharp.org/">F#</a>, etc.) form another family of <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming languages.  However, the strongest effort to build a language that holds to the principles of lambda-calculus inspired <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming such as immutability (purity) is the Haskell family.</p>

<p>There are a number of efforts to bring Haskell-like purity to web programming, inspired by the potential benefits the <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span>-style holds for managing complex state in <span class="glossary-term" data-term="asynchronous">asynchronous<span class="glossary-popup">Operations that occur independently of the main program flow, allowing the program to continue executing while waiting for the operation to complete.
</span></span> and distributed applications.  Firstly, it is possible to compile Haskell code directly to JavaScript (using <a href="https://github.com/ghcjs/ghcjs">GHCJS</a>) although the generated code is opaque and requires a runtime.  Another promising and increasingly popular haskell-inspired language for client-side web development is <a href="https://elm-lang.org/">Elm</a>, although this again requires a runtime.  Also, Elm is rather specialised for creating interactive web apps.</p>

<p>The JavaScript-targeting Haskell derivative we are going to look at now is <a href="https://www.purescript.org/">PureScript</a>.  The reason for this choice is that PureScript generates standalone and surprisingly readable JavaScript.  For a full introduction to the language, <a href="https://leanpub.com/purescript/read">the PureScript Book</a>, written by the language’s creator, is available for free.  However, in this unit we will only make a brief foray into PureScript as a segue from JavaScript to Haskell.  To avoid overwhelming ourselves with minor syntactic differences we will also endeavor to stick to a subset of PureScript that is syntactically the same as Haskell.</p>

<h2 id="hello-functional-language">Hello Functional Language</h2>

<p>Without further ado, here is some PureScript code.  Fibonacci number computation is often called the “hello world!” of <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fibs</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fibs</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fibs</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Woah!  A function for Fibonacci numbers that is about as minimal as you can get!  And the top line, which just declares the type of the function, is often optional - depending on whether the compiler can infer it from the context.  Having said that, it’s good practice to include a type declaration, especially for top-level functions (functions defined without indentation and therefore in-scope everywhere in the file).  This function takes an <code class="language-plaintext highlighter-rouge">Int</code> (integer) parameter, and returns an <code class="language-plaintext highlighter-rouge">Int</code>.  Note that the arrow shorthand for the function type definition is highly reminiscent of the JavaScript fat-arrow (<code class="language-plaintext highlighter-rouge">=&gt;</code>) though skinnier.</p>

<p>The next three lines define the actual logic of the function, which very simply gives a recursive definition for the <code class="language-plaintext highlighter-rouge">n</code>th Fibonacci number.  This definition uses a feature common to many <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming languages: <em><span class="glossary-term" data-term="pattern matching">pattern matching<span class="glossary-popup">A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.
</span></span></em>.  That is, we define the <code class="language-plaintext highlighter-rouge">fibs</code> function three times, with the first two definitions handling the base cases.  It says, literally: “the 0th and 1st fibs are both 1”.  The last line defines the general case, that the remaining fibonacci numbers are each the sum of their two predecessors.  Note, this definition is not perfect.  Calling:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>would be a bad idea.  Good practice would be to add some exceptions for incorrect input to our function.  In a perfect world we would have a compiler that would check types dependent on values (actually, languages that support dependent types exist, e.g. the <a href="https://www.idris-lang.org/">Idris</a> language is an interesting possible successor to Haskell in this space).</p>

<p>Python3.10+ has taken inspiration from this pattern, and has its own alternative to <span class="glossary-term" data-term="pattern matching">pattern matching<span class="glossary-popup">A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.
</span></span>, with a slightly more verbose <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span>. This is semantically identical to the PureScript definition, where we use <span class="glossary-term" data-term="pattern matching">pattern matching<span class="glossary-popup">A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.
</span></span> against the inputs. For completeness, all functions should aim to provide the type definition, similar to what we did in the PureScript example.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fibs</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">match</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">case</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fibs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> 

<span class="k">print</span><span class="p">(</span><span class="n">fibs</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
</code></pre></div></div>

<p>One thing you will have noticed by now is that Haskell-like languages are light on <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span>, this is obvious when compared next to the Python alternative.  Especially, use of brackets is minimal, and typically to be avoided when evaluation order can be inferred correctly by the compiler’s application of lambda-calculus inspired precedence rules for function and operator application.</p>

<p>We can define a <code class="language-plaintext highlighter-rouge">main</code> function for our program, that maps the <code class="language-plaintext highlighter-rouge">fibs</code> function to a (<code class="language-plaintext highlighter-rouge">Nil</code>-terminated) linked-list of numbers and displays them to the console like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">log</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">map</span> <span class="n">fibs</span> <span class="o">$</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>
</code></pre></div></div>

<p>and here’s the output when you run it from the command line:</p>

<blockquote>
  <p>(1 : 2 : 3 : 5 : 8 : 13 : 21 : 34 : 55 : 89 : Nil)</p>
</blockquote>

<p>I’m omitting the type declaration for <code class="language-plaintext highlighter-rouge">main</code> because the type for functions that have input-output side-effects is a little more complicated, differs from haskell - and the compiler doesn’t strictly need it yet anyway.</p>

<p>The above definition for <code class="language-plaintext highlighter-rouge">main</code> is a chain of functions and the order of evaluation (and hence how you should read it) is right-to-left.  The <code class="language-plaintext highlighter-rouge">$</code> symbol is actually shorthand for brackets around everything to the symbol’s right.  In other words, the above definition for <code class="language-plaintext highlighter-rouge">main</code> is equivalent to:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">log</span> <span class="p">(</span> <span class="n">show</span> <span class="p">(</span> <span class="n">map</span> <span class="n">fibs</span> <span class="p">(</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="p">)))</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">$</code> is not special <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span> (i.e. it is not a keyword in the language definition).  Rather, it is an operator defined in the PureScript Prelude like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">infixr</span> <span class="mi">0</span> <span class="n">apply</span> <span class="n">as</span> <span class="o">$</span>
</code></pre></div></div>

<p>That is, <code class="language-plaintext highlighter-rouge">$</code> is an infix, right associative operator with binding precedence 0 (the lowest) that invokes the apply function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div></div>

<p>Woah!  What is f and what is <code class="language-plaintext highlighter-rouge">x</code>?  Well, in PureScript functions are generic by default - but we (and the compiler) can infer, since f x  is a function call with argument x, that f is a function and x is… anything.  So apply literally applies the function f to the argument x.  Since the binding precedence of the <code class="language-plaintext highlighter-rouge">$</code> operator is so low compared to most things that could be placed to its right, brackets are (usually) unnecessary.</p>

<hr>

<h3 id="exercise">Exercise</h3>

<ul>
  <li>If one didn’t happen to like the fact that function chaining with the $ operator reads right to left, how would one go about creating an operator that chains left to right?  (Hint: infixl is a thing and you will need to make a slightly different apply function also).</li>
</ul>

<hr>

<p>So anyway, back to the chain of functions in <code class="language-plaintext highlighter-rouge">main</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">log</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">map</span> <span class="n">fibs</span> <span class="o">$</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">log</code> is a function that wraps JavaScript’s console.log
<code class="language-plaintext highlighter-rouge">show</code> is a function that is overloaded to convert various types to strings.  In this case, we’ll be showing a List of Int.
<code class="language-plaintext highlighter-rouge">map</code> is (equivalent to our old friend from our JavaScript exercises) a function that applies a function to stuff inside a… let’s call it a container for now… in this case our Container is a List.
<code class="language-plaintext highlighter-rouge">1..10</code> uses the <code class="language-plaintext highlighter-rouge">..</code> (range) infix operator to create a List of Int between 1 and 10.</p>

<h2 id="peeking-under-the-hood">Peeking under the hood</h2>

<p>So all this may seem pretty foreign, but actually, since we’ve already covered many of the <span class="glossary-term" data-term="functional">functional<span class="glossary-popup">Functional languages are built around the concept of composable functions.  Such languages support <em>higher order functions</em> which can take other functions as arguments or return new functions as their result, following the rules of the <em>Lambda Calculus</em>.
</span></span> programming fundamentals in JavaScript, let’s take a look at the JavaScript code that the PureScript compiler generates for <code class="language-plaintext highlighter-rouge">fibs</code> and <code class="language-plaintext highlighter-rouge">main</code> and see if anything looks familiar.  Here’s <code class="language-plaintext highlighter-rouge">fibs</code>, exactly as it comes out of the compiler:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fibs</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="k">return</span> <span class="nx">fibs</span><span class="p">(</span><span class="nx">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fibs</span><span class="p">(</span><span class="nx">v</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span> 
</code></pre></div></div>

<p>Woah!  It’s pretty much the way a savvy JavaScript programmer would write it.  The one part that may look a bit unusual are the expressions like <code class="language-plaintext highlighter-rouge">v - 1 | 0</code>.  Of course, JavaScript has no <code class="language-plaintext highlighter-rouge">Int</code> type, so this is PureScript trying to sensibly convert to the all-purpose JavaScript <code class="language-plaintext highlighter-rouge">number</code> type.  The <code class="language-plaintext highlighter-rouge">|</code> is a bitwise OR, so <code class="language-plaintext highlighter-rouge">|0</code> ensures that resulting expression is an integer which is both <a href="https://stackoverflow.com/questions/44778826/why-does-the-purescript-compiler-generate-lots-of-0">a safety measure and a potential optimisation</a>.  It’s a situation where the declared types give the PureScript compiler more information about the intent of the code than would otherwise be present in JavaScript, and which it’s able to use to good effect.</p>

<p>At first glance the code generated for <code class="language-plaintext highlighter-rouge">main</code> is a bit denser.  Here it is, again as generated by the compiler but I’ve inserted some line breaks so we can see it a little more clearly:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="nx">Control_Monad_Eff_Console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
  <span class="nx">Data_Show</span><span class="p">.</span><span class="nx">show</span><span class="p">(</span>
    <span class="nx">Data_List_Types</span><span class="p">.</span><span class="nx">showList</span><span class="p">(</span><span class="nx">Data_Show</span><span class="p">.</span><span class="nx">showInt</span><span class="p">)</span>
  <span class="p">)(</span>
    <span class="nx">Data_Functor</span><span class="p">.</span><span class="nx">map</span>
     <span class="p">(</span><span class="nx">Data_List_Types</span><span class="p">.</span><span class="nx">functorList</span><span class="p">)(</span><span class="nx">fibs</span><span class="p">)(</span><span class="nx">Data_List</span><span class="p">.</span><span class="nx">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">10</span><span class="p">))</span>
  <span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Each of the functions lives in an object that encapsulates the module where it is defined.  That’s pretty standard JavaScript practice.  The rest is just function calls (application).  The call to the range function is interesting:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Data_List</span><span class="p">.</span><span class="nx">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>Woah! It’s a curried function!  Data_List.range(1) returns a function that creates lists of numbers starting from 1.  The second call specifies the upper bound.</p>

<hr>

<h3 id="exercise-1">Exercise</h3>

<ul>
  <li>What other functions called in the JavaScript code generated for the above definition of <code class="language-plaintext highlighter-rouge">main</code> are curried?  Why?</li>
</ul>

<hr>

<h2 id="tail-call-optimisation">Tail Call Optimisation</h2>

<p>Our definition for <code class="language-plaintext highlighter-rouge">fibs</code> was recursive.  This has a nice <span class="glossary-term" data-term="declarative">declarative<span class="glossary-popup">Declarative languages focus on declaring <em>what</em> a procedure (or function) should do rather than <em>how</em> it should do it.
</span></span> style about it.  The definition is very close to a mathematical definition.  But at some point in your training for <span class="glossary-term" data-term="imperative">imperative<span class="glossary-popup">Imperative programs are a sequence of statements that change a programs state.  This is probably the dominant paradigm for programming languages today.  Languages from Assembler to Python are built around this concept and most modern languages still allow you to program in this style.
</span></span> programming you will have most likely been told that recursion is evil and inefficient.  Indeed, we’ve seen at the start of this course that there is overhead due to creating new stack frames for each function call.  Looping recursively creates a new stack frame for each iteration and so our (finite) stack memory will be consumed linearly with the number of iterations.  However, there are certain patterns of recursive function calls that our compiler can easily recognise and replace with an iterative loop.  We can see this happening directly in PureScript if we reconfigure our <code class="language-plaintext highlighter-rouge">fibs</code> definition to use a tail call.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibs</span> <span class="n">n</span> <span class="o">=</span> <span class="n">f</span> <span class="n">n</span> <span class="mi">0</span> <span class="mi">1</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="mi">0</span> <span class="kr">_</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">f</span> <span class="n">i</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>In general, as we have seen with <code class="language-plaintext highlighter-rouge">$</code>, PureScript (and Haskell) have relatively few keywords, instead preferring functions and operators built with the language itself in the Prelude (the base library functions that are available by default).  The <code class="language-plaintext highlighter-rouge">where</code> keyword, however, is one of the exceptions.  It allows us to make some local definitions inside the scope of the function.  Here we define <code class="language-plaintext highlighter-rouge">f</code> whose first parameter is an iteration counter, whose base case is <code class="language-plaintext highlighter-rouge">0</code>.  The key feature of <code class="language-plaintext highlighter-rouge">f</code> is that its recursive call is the very last thing to happen in the function body.  That is, it is in the tail position.</p>

<p>The other important aspect of PureScript that we are encountering for the first time in the above definition is that indentation is used to determine scope (as in python).</p>

<p>Here’s the JavaScript that is generated this time:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fibs</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">$copy_v</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">$copy_v1</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">$copy_b</span><span class="p">)</span> <span class="p">{</span>
               <span class="kd">var</span> <span class="nx">$tco_var_v</span> <span class="o">=</span> <span class="nx">$copy_v</span><span class="p">;</span>
               <span class="kd">var</span> <span class="nx">$tco_var_v1</span> <span class="o">=</span> <span class="nx">$copy_v1</span><span class="p">;</span>
               <span class="kd">var</span> <span class="nx">$tco_done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
               <span class="kd">var</span> <span class="nx">$tco_result</span><span class="p">;</span>
               <span class="kd">function</span> <span class="nx">$tco_loop</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
                   <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                       <span class="nx">$tco_done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
                       <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
                   <span class="p">};</span>
                   <span class="nx">$tco_var_v</span> <span class="o">=</span> <span class="nx">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
                   <span class="nx">$tco_var_v1</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
                   <span class="nx">$copy_b</span> <span class="o">=</span> <span class="nx">v1</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">|</span> <span class="mi">0</span><span class="p">;</span>
                   <span class="k">return</span><span class="p">;</span>
               <span class="p">};</span>
               <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">$tco_done</span><span class="p">)</span> <span class="p">{</span>
                   <span class="nx">$tco_result</span> <span class="o">=</span> <span class="nx">$tco_loop</span><span class="p">(</span><span class="nx">$tco_var_v</span><span class="p">,</span> <span class="nx">$tco_var_v1</span><span class="p">,</span> <span class="nx">$copy_b</span><span class="p">);</span>
               <span class="p">};</span>
               <span class="k">return</span> <span class="nx">$tco_result</span><span class="p">;</span>
           <span class="p">};</span>
       <span class="p">};</span>
   <span class="p">};</span>
   <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">n</span><span class="p">)(</span><span class="mi">0</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Obviously, it’s a less direct translation than was generated for our previous version of <code class="language-plaintext highlighter-rouge">fibs</code>.  However, you can fairly easily understand it still.  Hint, the <code class="language-plaintext highlighter-rouge">tco_</code> prefix in many of the generated variable names stands for “<span class="glossary-term" data-term="tail call optimisation">Tail Call Optimisation<span class="glossary-popup">A compiler feature that optimises tail-recursive functions to prevent additional stack frames from being created, effectively converting recursion into iteration.1
</span></span>” and the local function <code class="language-plaintext highlighter-rouge">f</code> is a curried function, as are all functions of more than one argument in PureScript.  The important thing is that the recursive call is gone, replaced by a while loop.</p>

<p>We have seen all we need for now of PureScript.  It’s a small but nicely put together language.  It takes the best features of Haskell and reinterprets some of them quite cleverly to achieve relatively seamless interop with JavaScript.  However, it’s still a bit niche.  For the remainder of this unit <a href="/haskell1/">we’ll dive more deeply into Haskell</a>, which has a long history and is supported by a very large and active community across academia and industry.</p>

<div class="glossary">
  <h2 id="glossary">Glossary</h2>

  <p><em>Pattern Matching</em>: A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.</p>

  <p><em>Tail Call Optimisation</em>: A compiler feature that optimises tail-recursive functions to prevent additional stack frames from being created, effectively converting recursion into iteration.1</p>

</div>

	</div>
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/lambdacalculus/">&lt; <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span></a>
      
      
        
        
        <a id="right" href="/haskell1/">Creating and Running Haskell Programs &gt;</a>
      
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
</div>

</article>
      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <!-- <p class="feed-subscribe">
            <a href="/feed.xml">
              <svg class="svg-icon orange">
                <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
              </svg><span>Subscribe</span>
            </a>
          </p> -->
        </div>
        <div class="footer-col">
          <p>Examples and tutorials for various programming paradigms.</p>
        </div>
      </div>
  
      <div class="social-links">
<ul class="social-media-list">
<li><a href="https://github.com/tgdwyer"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">tgdwyer</span></a></li>
<li><a href="https://www.twitter.com/immersivecola"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">immersivecola</span></a></li>
</ul>
</div>
  
    </div>
  
  </footer>


</body>